# -*- coding: utf-8 -*-
"""MyBigDataComputing'sProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pH5O2YlONDFwjKjmTYIUbbe8iMYGiTeN

#Big Data Computing Project

This notebook contains the Michele Spina's (1711821) project for the cource of Big Data Computing of the a.y. 2021/22.

Before start:
Create a directory data and uploat the datesets

## Initialize pyspark
"""

#install pyspark
!pip install pyspark

# Import libraries
import pyspark
from pyspark.sql import *
from pyspark.sql.types import *
from pyspark.sql.functions import *
from pyspark import SparkContext, SparkConf

# Create the session
conf = SparkConf().set("spark.ui.port", "4050").set('spark.executor.memory', '4G').set('spark.driver.memory', '45G').set('spark.driver.maxResultSize', '10G')

# Create the context
sc = pyspark.SparkContext(conf=conf)
spark = SparkSession.builder.getOrCreate()

spark

sc._conf.getAll()

"""## The Dataset

For this project I choose a dataset from Kraggle about airline passeger satistation. 
The goal of this project is to predict if the passegers are satisfied or not, so I have to apply a binary prediction.

[Source](https://www.kaggle.com/datasets/teejmahal20/airline-passenger-satisfaction?select=train.csv)



---



Now let's import the dataset and observe what it contains.
"""

# Import the dataset

#from google.colab import drive
import pandas as pd

GDRIVE_DIR = "/content/gdrive" # Your own mount point on Google Drive
GDRIVE_HOME_DIR = GDRIVE_DIR + "/My Drive" # Your own home directory
GDRIVE_DATA_DIR = GDRIVE_HOME_DIR + "/BigDataComputing"
TRAIN_DATA_PATH = GDRIVE_DATA_DIR + '/train.gsheet'
TEST_DATA_PATH = GDRIVE_DATA_DIR + '/test.gsheet'

TRAIN_DATA_PATH = '/content/data/train.csv'
TEST_DATA_PATH  = '/content/data/test.csv'

#drive.mount(GDRIVE_DIR, force_remount=True)

"""Remember to import `test.csv` and `train.csv` inside a directory named `data` ![image.png](data:image/png;base64,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QAABBBDIVqDQYKqazjlz5rgz8N9j6mZm9EbN/urFb6eoDlJ2Oa9rCkyfPt09NWvNpfnOUdO3btXQCA1ZTZtttpnZd999vREfnnvuOfPCCy+Yzz//3CQNpuqM9+1vf9vssMMOXo29hjF79dVX1zi8bbfd1qy11lpm2LBhRs35ml566SXvfPT+zTffNJ9++qnerjENGjTI24cWvPLKK6a3t9d8+OGHa6zHDAQQQAABBNpRoNBgKsCiajGDzdB5huB2/MHQObUymGr/GnVh1KhR3qs+p50233xzc84555iNNtqopgj1wr/tttvM0UcfXbdX/j777GN++tOfmvXWW69me3147733vGCroKtJw05dc8013vuo/+kfZ/fff79bvM4665jTTz/dDB482DsOt2DVGx3j448/bn7/+9+bzz77zL+I9wgggAACCLSdgAumRfTKl57/8aJxnZea0bZPjFIZqtk6+eSTmymuI7dtdTAVerM/IzvttJM566yzzNprrx17DcOGixo9erQ5+OCD626r7fSAh9dff91ssMEG5uqrr667vj+Ybr311mby5MnedvU26unpMZdddlm9VViGAAIIIIBA5QVcMC2iV7601KNePevV1K5Jg+RrWKgknZm8DWL+p/LV6WT48OHemnoEqR2gP2ZTFgcEyhBM1aSvp3alnS655BKzxRZbeJsrQKq8hQsXGgXC/fbbz6jZ3U7BYKqHPVx00UV2sVm6dKn55z//6TXfa1B+3RZgA+8777xjJk2a5K276667ek35hxxyiFFtqyY1+d96663ee5Wjwfw1nXvuuUbhWZPmPfbYY+bBBx/0fk8UiP3Hp9+bZ555xluX/yGAAAIIINCOAoUHUyGqmV3hUWOX2imrpnZ7q4ACqUKImmpVY8rUuEAZgqlGaND9wWmmPffc0/tHid1W56Pe8f7pjDPOMLvttps3KxhMVcu+//77e8sUCBUM/dN3v/tdc+yxx4Zuq5lxvfLVhP+73/3O3UZw5plnmuXLl/t34dW+qhZW00MPPRQ5Zm/NRnxAAAEEEECgogIumBbVlB90soO3xw0RFdyOz/kLVD2Y6r7N3Xff3YNSjeX5558fihbV+Unb2trMJ554wrz11ls126uD08yZM73aUS1QjalqTu0UF0z79u3r1ezrqVO6V/Xhhx+2m7pX/60E6kB14YUXumW8QQAB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i82MGTMa3o4NEEAAAQQQQCAbARdMucc0G1BKaZ3AyJEjzbhx45o6gPnz55uurq6mymBjBBBAAAEEEEgnUBNMG2nK7z74o9A9jn5w/dD5zEQgT4H+/fubO+64I5NdEE4zYaQQBBBAAAEEGhaoCabauqenJ1EhBNNETKxUkICa8KdPn55qb4sWLTL6RRg2bJjbnnDqKHiDAAIIIIBAYQIE08Ko2VGeAs0G0wkTJphJkyYVHk4POOAAo1sQNC1YsMDcfvvteTI1VPa5555rNtlkE6OWlIkTJ3qvDRXAyggggAACCDQoQDBtEIzVyymQRTDVmRUdThVKDz/8cA/12WefTV3rm8dVmTlzpll77bW9ok866STzxRdf5LEbykQAAQQQQMAJuGDaaK98mvKdIW9KIJBVMNWpFBlOCaYl+OHhEBBAAAEESiPggmmjvfIJpqW5hhzIKoEsg6lA8w6n2267rVlrrbW8WwfUnK/ppZdeMt3d3d77N99803z66afee///tI3OdccddzSff/65ee6558ySJUtim9m13Te+8Q2z0047mY022si89tpr5sUXXzRvvfWWv3iz4YYbmk033dSbp6b8vn37eu+nTZvm1Zh++OGH5p133qnZJskHlbnnnnuarbbayqxcudK88MILZunSpd451Nt+s802M7vuuqvZbrvtvO1efvllb9ugjcrXsWtatmyZ+eSTT0KL3WKLLcz663/VQVMG1AKHMjETAQQQaJlATTClV37LrgM7blIg62Cqw8kznN5www11z3jOnDnm/vvvr1lHTf5HHnmka163C/V7e9ddd5k///nPdlbN6/e//33zwx/+0Kyzzjo18/VBfwDUZP/KK694y3QvqYJg1KRg+otf/CJq8RrzFQJV5vbbb7/Gss8++8zcdttt5m9/+9sayzbffHPzs5/9zAvSwYUK5A888IC55ZZbXCCfOnWq2WGHHbxVH3zwQRfw/dv26dPHzJo1y/sHgeafffbZ3vn71+E9AggggEBrBWqCqQ6FXvmtvSDsPZ1AHsFUR5JXOG00mB5yyCHm+OOPr4vz/PPPm8svv7xmHf+tAjULfB9Ua6jaUf0xyDKYKghecsklRiGz3qROXzfeeKNbZeONN/a2W3fddd28sDcaTeGqq67yFumhCieeeKL3/v333zennXbaGpvsv//+5uSTT/bmr1ixwpx66qlrrMMMBBBAAIHWChBMW+vP3jMSyCuY6vCC4VQ9+BWKmplUK6nmdQXOffbZxyvq1VdfNbfeeqv3Xs3cH3/8sfd+jz328IKWgp6mhQsXmnvuucdrhj7ssMPM3nvv7c3X/xRMFVA1aWzXK6+80nuv/6npWrWJar7Xfr/1rW+5pno1z+s8FSLV3K1J56lj1KShuBRgP/jgA68cb2bM/1Sebh/QpG3vvvtu8+STT3pN6QrMgwYNciXoOJ9++mnvs/arc9ak2tFHHnnEPPbYY97TvA488EB3fFput5ONan7trQfad/CWg7POOsvssssu2szcd9995uabb/be8z8EEEAAgfIIEEzLcy04kiYE8gymOix/OM0imNpT9ddoRvXK9/eO/+tf/+o1f9vt9fqTn/zEKLBpevvtt40CmKaDDz7YjB492nuvezJ//vOfu6ZvzdRjWydPnuwt1+0AY8aM8d7b//n322ivfN1PamstVbaa2t944w1btPeq5VpPkx4He/HFF3vv9VjY9dZbz3uvWxSCQ2hdeOGF3r2qWkGh1dY+n3766Wb33Xf3tvvHP/5hbrrpJu+9/Z+a8W1w1b5Vs8qEAAIIIFAuARtM/x8AAAD//7nLBb4AADfXSURBVO3dCbQcU+LH8RsJiUQsscVOLLHv5CAEEztDhBlmyBh7Yo99HyYGIXaxMxNCGJHhOAxjy0gIY0Ss7yEktvgTeyJEIv/3u5l73a7X/bq7uqq63+vvPUe6u7rqVvWnX+L37lbtDjnkkHmmqTQ0NOihaBnRZ1befQaMXTjvdjYikKbARhttZK644oo0T+HrHjx4sJk0aZJ/XcmT/v37m913391W8cYbbzT7DFtuuaU56qij7Pvff/+9Oe6445qdrn379uamm24y7dq1M/PmzTOHH3643adv377mwAMPtM9/+uknM2jQIPPzzz/nHH/MMceYRRdd1B43bNgwo/1cUZ0dOnSwL4844ohmx7r98j0edNBBZocddrBvvfrqq+bqq69uttsiiyzit8+aNcsce+yxdp/rrrvOLLzw/H9HHn74YTNmzJicYzfZZBOz66672m0vv/yyeeyxx+zztdde25x66qn2+bfffmtOOukkf5yOcfVPnz7dnH766f49niCAAAII1I7A//3f/9mLafeHP/xhnv7HRjCtnS+HKyldoK0GU4XJzTbbzEK8/fbb5rbbbsuLct5555kuXbrY90444QQzY8YMG+4U8lz5/PPPzUMPPWRefPFFM2fOHLe54GMlwfT88883K6+8sq1bvzAodOcr2223nb3O7777zjz33HN2FwXK9ddf3z5X0B4/frwNn5988km+KnK2XX/99aZTp052m8KnQqjKySefbNZdd137fPTo0eaRRx6xz/kDAQQQQKC2BHwwpcW0tr4YrqY8gbYaTM8++2zTo0ePsjCuvPJK8/rrr9tjBgwYYPr06ZNzvMLe119/bV544QXz6KOP2hCbs8P/XlQSTIcPH246duxoazrxxBONgmepZbnlljPnnHOOD5juOLXmTp482YZUtcLmK2ot3mqrrexbTz/9tLnrrrvs8xtvvNEsuOCCtmV44MCBOS3D+ephGwIIIIBAdQQIptVx56wJC7TVYHrRRReZ7t27l6WlVlXX+qgDt912W7P//vv7FtVoZU888YS55557opvt8IC4Xfm33nqrHVqgSg877LBmdRfboK58tfyuscYavp7wGLUIy+azzz4LN5tlllnGXHzxxXbbN998YzTsYp111jGnnHKK3fbBBx+YCy64IOcYXiCAAAII1I6AD6Z05dfOl8KVlC/QVoNp2GI6depU88orrxTFefbZZ81XX33VbL9VV13VbL/99jaoLbnkkjmBT2Nmr7nmmpxjKmkxDbvU1TWvMZ9xilo5dc0aI6rrd62wqkvjZTVkINrFr6EDiy22mD2dAqnGu2688cb2tQLz888/b5/zBwIIIIBA7Qn4YEpXfu19OVxR6QJtNZiGXfETJ0404ZjR0nWa76kWSU2k6tmzp31T3fua4KRHVyoJpmq1VOuliiY+Fep6d+cq9VEBVeNuF1hgAXvIuHHjzB133JFzeDih7MknnzS9e/e2gXbu3LnmyCOPzNmXFwgggAACtSVAMK2t74OriSnQVoOpuuGbfmm0KpqwpDA5e/bsvEpdu3bNGcs5dOhQs/jii9t9NWYz2u290EILGY0F1aRHlXBsql5XEkzVhb7eeuupGjuh8rLLLrPPwz/C87sVBxQiFcZV3nnnHZPvOK1SoNUKVPLNsFfovvbaa+3nkpkbjvDmm28arTxAQQABBBCoXQEfTOnKr90viSsrLtBag+mee+5p+vXrZz+g/jKeddZZOR9WXdkKWXpU0cx8Bc6wZVPbNetcYym1vNI//vEP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Psrs4osvti2b0ffKeb3QQgvZkKsgXEqJBtOtttrKHHrooXZN1paOv/fee83jjz9udykWTN966y1z+eWX230VzM8880zbwtpS/foeZUZBAAEEEKhMwP2/uB1d+ZVBVnq0gqlmCCuEKYzVQqmFYKoufTdzulwTdZ9fffXV/jC1HGoxeXXfqxVTXetqrVNRd/jpp5/u9/31r39t9t57b/ta4U4td88884zdf6eddrLdxeo+Vxk3bpxtMbMvmv6IBtMffvjBTJgwwa6/qVY9tW4utthibnf7qKCnxePVaq4WVLXyKrC6oqCkwORKNJiq6/vFF1+03dBbbLGF0X+ufPXVV+aUU05xL20Ibmkd0wsuuMAvaK8uboU6dYlriMGBBx7oQ7T+8TjrrLN8vXGeNP27Y7bddlt/qAKePBWON998czuMwL/Z9CQaTG+44QajcKuiltxnn33WvPTSS2brrbe29epnQEXf4ZFHHmnkvPLKK5suXbrYFuqmsfX2fX3Oa6+91j7X51JdKvqFwH0P2kffo36GZKG/s27hf+2rXwA01IGCAAIIIBBfgGAa3y7RI10wVaW1Ek5rIZhqTVR1jccpMh0wYIA99KeffrILySuguKKuWbWGqWj74Ycf7t6yrV9unKh+UYjeHUlBb5111rH7K+i6erQhDKYaR6puaoVDVxS6FLDCoQX6zv/973+7Xeyjhgm4fdQVfd999/n3w2D6/PPPm1tvvdW/pye9evWyQcxtVEDXuFaVllpMwxZmjY094YQT7BhZV4/GgaouF+j1MxK2xrr9SnnUdchB439VnnzySXP33XfnHLrLLruY3/zmN35bGEw15vfYY4+172nYh1quw+9X4V/X54paNMMeoWKTn2Sv4KtfQFSvhjaE36PqVZjVeFUVfX+VtO7bSvgDAQQQqHMBgmmN/ACEwVSXVAvhtLUH0759+9oWPnkqmGo9VrWYhUUrD6gbWcFD61hqP5XevXv7Vs1HH3202XE9e/a04xq1b/TuSWEw/ec//2n+/ve/a7ecopCjSToqGg5w3HHH5byvF2H4deNR3U4umCr4ugk87j33+Je//MXfGEGh1LUetxRM9Z271tyRI0faVlxXn3s87LDDbIukXkdbi90+pTyq1fqggw6yu+pzHH300TnB0tWh8az5xphqbKlrGdZ4X40NjRYNN9B+Kg8++KB56KGH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)"""

train_df = spark.read.load(TRAIN_DATA_PATH, 
                           format="csv", 
                           sep=",", 
                           inferSchema="true", 
                           header="true")

test_df = spark.read.load(TEST_DATA_PATH, 
                           format="csv", 
                           sep=",", 
                           inferSchema="true", 
                           header="true")

train_df.head()

test_df.head()

"""This datase have been already cleaned, but observe the consistents of the data if fundamental practice before use a Dataset."""

#I want to concatene test and union to observe the dataset
df = train_df.union(test_df)
df.show(n=5, truncate=False)

df.printSchema()

print("The shape of the dataset is {:d} rows by {:d} columns".format(df.count(), len(df.columns)))

print(df.dtypes)

df.describe("age").show()

pan_df = df.toPandas()
pan_df.Age.plot.hist()

pan_df.isnull().sum()

pan_df.info()

"""`Arrival Delay in Minutes` column contains 379 null-values. There are many differt ways to manage this inconcistent


*   Delete the inconsistent column
*   Delete the inconsistent rows
*   Substitute inconsistent using mean value
*   Substitute inconsistent using mean value adding a boolean attribute to individuate virtual values from original
*   Use linear regression to substitute inconsistent values

We'll apply the 4th options.
"""

pan_df.describe()

import matplotlib.pyplot as plt
import seaborn as sns

oe=['g','r']
fig = plt.figure(figsize=(32,32))

rows = 6
cols = 4
pos = 1

for col_name in pan_df.columns[2:]:
  plt.subplot(rows,cols,pos)
  plt.style.use('seaborn')
  plt.tight_layout()
  sns.set_context('talk')
  sns.histplot(data=pan_df, x=col_name, hue="satisfaction", linewidth = 1.8, multiple="stack",palette=oe)
  pos += 1

def correlation_matrix(df: DataFrame):
  fig, ax = plt.subplots(figsize=(10, 10))
  sns.heatmap(df.corr(), cmap="YlGnBu")

"""## Correlation Matrix"""

correlation_matrix(pan_df)

"""# Drop columns and rows

Drop the uselss and redondant colums
"""

COLUMNS_TO_DROP = ['_c0', 'id','Arrival Delay in Minutes']

COLUMNS_TO_DROP_AGAIN = ['satisfaction']

"""Drop also the row with null value"""

df = df.drop(*COLUMNS_TO_DROP)
df.na.drop()
#df = df.withColumn("Satisfied", col('satisfaction') == 'satisfied')
#df = df.drop('satisfaction')
df.schema

"""# Machine Learning Models"""

df.show(n=5, truncate=False)

"""#### Define the pipeline
Here I defined a general pipeline for all the models.

In particular I'll use this Pipeline:
<ul>
  <li><code>StringIndexer</code>: it encodes string column of labels to a column of label indices;</li>
  <li><code>OneHotEncoder</code>: it maps a categorical feature (represented as a lable index) to a binary vector with at most a single one-value indicating the presence of a specific feature value from among the set of all feature values;</li>
  <li><code>VectorAssembler</code>: it is a transformer that combines a given list of columns into a single vector column;</li>
  <li><code>StandardScaler</code>: it transsforms a dataset of <code>Vector</code> rows, normalizing each feature to have unit standard deviation and/or zero mean;</li>
  <li><code>MODEL</code>: the model to train that could be the <code>Logistic Regression, Decision Tree or Random Forest</code>.</li>
</ul>
"""

from typing import List, Callable
def general_pipeline(df: DataFrame, numerical_features: List[str], categorical_features: List[str], target_variable: str, with_std: bool = True, with_mean: bool = True, scaler: bool = False):
  from pyspark.ml import Pipeline
  from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler, StandardScaler
  
  indexers = [StringIndexer(inputCol=c, outputCol="{}_indexed".format(c), handleInvalid="skip") for c in categorical_features]
  
  encoder = OneHotEncoder(inputCols=[indexer.getOutputCol() for indexer in indexers], outputCols=["{}_encoded".format(indexer.getOutputCol()) for indexer in indexers], handleInvalid="keep")
  
  label_indexer = StringIndexer(inputCol=target_variable, outputCol="label", handleInvalid="skip")
  
  assembler = VectorAssembler(inputCols=encoder.getOutputCols() + numerical_features, outputCol="features")
  
  if scaler:
    scaler_vect = StandardScaler(inputCol=assembler.getOutputCol(), outputCol="std_"+assembler.getOutputCol(), withStd=with_std, withMean=with_mean)
    stages = indexers + [encoder] + [label_indexer] + [assembler] + [scaler_vect]
  else:
    stages = indexers + [encoder] + [label_indexer] + [assembler]
    
  pipeline = Pipeline(stages=stages)
  transformer = pipeline.fit(df)
  df_transformed = transformer.transform(df)
  return transformer, df_transformed

from pyspark.ml.classification import LogisticRegression, DecisionTreeClassifier, RandomForestClassifier
from pyspark.ml.evaluation import BinaryClassificationEvaluator

CATEGORICAL_FEATURES = ['Gender', 'Customer Type', 'Class', 'Type of Travel'] # they are the CATEGORICAL FEATURES
NUMERICAL_FEATURES = ['Age', 'Flight Distance', 'Inflight wifi service', 'Departure/Arrival time convenient', 'Ease of Online booking', 'Gate location', 'Food and drink', 'Online boarding', 'Seat comfort', 'Inflight entertainment', 'On-board service', 'Leg room service', 'Baggage handling', 'Checkin service', 'Inflight service', 'Cleanliness', 'Departure Delay in Minutes']

"""<code>plot_recision_recall, plot_coefficients, plot_roc, plot_confusion_matrix, calculate_metrics, metrics_calculation</code> are utility functions."""

def plot_precision_recall(model):
  training_summary = model.summary
  precision_recall = training_summary.pr.toPandas()
  fig, ax = plt.subplots(1, 1, figsize=(8,6))
  _ = sns.lineplot(x=precision_recall['recall'], y=precision_recall['precision'], marker="s", axes=ax)
  _ = ax.set_xlabel("Recall", labelpad=20)
  _ = ax.set_ylabel("Precision", labelpad=20)
  _ = ax.set_title("Precision vs. Recall")

import numpy as np
def plot_coefficients(model):
  theta = np.sort(model.coefficients)
  fig, ax = plt.subplots(1, 1, figsize=(8,6))
  _ = sns.lineplot(x=range(0,len(model.coefficients)), y=theta, marker="o", axes=ax)
  _ = ax.set_xlabel("Theta Index", labelpad=20)
  _ = ax.set_ylabel("Theta Value (log odds)", labelpad=20)

def plot_roc(model):
  roc = model.summary.roc.toPandas()

  fig, ax = plt.subplots(1, 1, figsize=(8,6))
  _ = sns.lineplot(x=roc['FPR'], y=roc['TPR'], marker="s", axes=ax)
  _ = ax.set_xlabel("False Positive Rate", labelpad=20)
  _ = ax.set_ylabel("True Positive Rate", labelpad=20)
  _ = ax.set_title("ROC Curve")
  print('Training Set AUC: {:.3f}'.format(model.summary.areaUnderROC))

import itertools
import numpy as np
def plot_confusion_matrix(cm, classes, normalize=False, title='Confusion matrix', cmap=plt.cm.Blues):
  if normalize:
    cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
    print("Normalized confusion matrix")
  else:
    print("Confusion matrix without normalization")
  
  print(cm)
  
  plt.imshow(cm, interpolation='nearest', cmap=cmap)
  plt.title(title)
  plt.colorbar()
  tick_marks = np.arange(len(classes))
  plt.xticks(tick_marks, classes, rotation=45)
  plt.yticks(tick_marks, classes)

  fmt = '.2f' if normalize else 'd'
  thresh = cm.max() / 2.
  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
      plt.text(j, i, format(cm[i, j], fmt),
               horizontalalignment="center",
               color="white" if cm[i, j] > thresh else "black")

  plt.tight_layout()
  plt.ylabel('True label')
  plt.xlabel('Predicted label')

from sklearn.metrics import confusion_matrix, precision_score, recall_score, accuracy_score, mean_squared_error, mean_absolute_error, r2_score

def calculate_metrics(predictions):
  y_true = predictions.select("label")
  y_true = y_true.toPandas()

  y_pred = predictions.select("prediction")
  y_pred = y_pred.toPandas()

  confusion_matrix_lr = confusion_matrix(y_true, y_pred, labels=[0.0, 1.0])
  plt.figure()
  plot_confusion_matrix(confusion_matrix_lr, classes=[0.0, 1.0], title='Confusion matrix lr')
  plt.show()

def metrics_calculation(y_test, pred):
  precision = precision_score(y_test, pred, average = "macro")
  recall = recall_score(y_test, pred, average = "macro")
  accuracy = accuracy_score(y_test, pred)
  f1score = (2 * (precision * recall))/(precision + recall)
  print('Precision metric: {}'.format(precision))
  print('Recall Metric: {}'.format(recall))
  print('Accuracy Metric: {}'.format(accuracy))
  print('F1-score Metric: {}'.format(f1score))

"""In the cell below there is the code to run the experiments that are present in the experiments dictionary."""

print(df.columns)

transformer, transformed = general_pipeline(df, NUMERICAL_FEATURES, CATEGORICAL_FEATURES, 'satisfaction', scaler = True)
train_df, test_df = transformed.randomSplit([0.7, 0.3])

"""## Binomial Logistic regression
Show the results for binomial logistic regression experiments (loading the previous models)
"""

from pyspark.ml.classification import LogisticRegression

lr = LogisticRegression()

lrmodel = lr.fit(train_df)

output = lrmodel.transform(test_df)

print(output)

calculate_metrics(output)

metrics_calculation(output.select("label").toPandas(), output.select("prediction").toPandas())

plot_roc(lrmodel)

evaluator = BinaryClassificationEvaluator()
print('Test Set AUC: {:.3f}'.format(evaluator.evaluate(output)))

"""## Decision Tree"""

from pyspark.ml.classification import DecisionTreeClassifier

lr = DecisionTreeClassifier()

lrmodel = lr.fit(train_df)

output = lrmodel.transform(test_df)

print(output)

calculate_metrics(output)

metrics_calculation(output.select("label").toPandas(), output.select("prediction").toPandas())

evaluator = BinaryClassificationEvaluator()
print('Test Set AUC: {:.3f}'.format(evaluator.evaluate(output)))

"""## Random Forest"""

from pyspark.ml.classification import RandomForestClassifier

lr = RandomForestClassifier()

lrmodel = lr.fit(train_df)

output = lrmodel.transform(test_df)

print(output)

calculate_metrics(output)

metrics_calculation(output.select("label").toPandas(), output.select("prediction").toPandas())

plot_roc(lrmodel)

evaluator = BinaryClassificationEvaluator()
print('Test Set AUC: {:.3f}'.format(evaluator.evaluate(output)))

"""#Hyper-tuning"""

train_df, test_df = df.randomSplit([0.7, 0.3])

"""## Logistic Regression"""

def matrix_factorization(train, k_fold=5):

    from pyspark.ml.tuning import CrossValidator, ParamGridBuilder
    from pyspark.ml.evaluation import RegressionEvaluator
    from pyspark.ml import Pipeline
    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler, StandardScaler


    indexers = [StringIndexer(inputCol=c, outputCol="{}_indexed".format(c), handleInvalid="skip") for c in CATEGORICAL_FEATURES]
    
    encoder = OneHotEncoder(inputCols=[indexer.getOutputCol() for indexer in indexers], outputCols=["{}_encoded".format(indexer.getOutputCol()) for indexer in indexers], handleInvalid="keep")
    
    label_indexer = StringIndexer(inputCol='satisfaction', outputCol="label", handleInvalid="skip")
    
    assembler = VectorAssembler(inputCols=encoder.getOutputCols() + NUMERICAL_FEATURES, outputCol="features")
    
    classifier = LogisticRegression()

    scaler_vect = StandardScaler(inputCol=assembler.getOutputCol(), outputCol="std_"+assembler.getOutputCol(), withStd=True, withMean=True)
    stages = indexers + [encoder] + [label_indexer] + [assembler] + [scaler_vect] + [classifier]    
      
    pipeline = Pipeline(stages=stages)
    '''    
    if target_variable != "label":
        df = df.withColumnRenamed(target_variable, "label")
    '''

    param_grid = ParamGridBuilder()\
        .addGrid(classifier.maxIter, [10, 100, 1000]) \
        .addGrid(classifier.regParam, [0.0, 0.05, 0.1]) \
        .addGrid(classifier.elasticNetParam, [0.0, 0.5, 1.0]) \
        .build()
    
    cross_val = CrossValidator(estimator=pipeline, 
                               estimatorParamMaps=param_grid,
                               evaluator=BinaryClassificationEvaluator(metricName="areaUnderROC"),
                               numFolds=k_fold,
                               collectSubModels=True # this flag allows us to store ALL the models trained during k-fold cross validation
                               )

    # Run cross-validation, and choose the best set of parameters.
    cv_model = cross_val.fit(train)

    return cv_model

tdf = train_df
cv_model_lr = matrix_factorization(tdf)

def summarize_all_models(cv_models):
    for k, models in enumerate(cv_models):
        print("*************** Fold #{:d} ***************\n".format(k+1))
        for i, m in enumerate(models):
            print("--- Model #{:d} out of {:d} ---".format(i+1, len(models)))
            print("\tParameters: lambda=[{:.3f}]; alpha=[{:.3f}] ".format(m.stages[-1]._java_obj.getRegParam(), m.stages[-1]._java_obj.getElasticNetParam()))
            print("\tModel summary: {}\n".format(m.stages[-1]))
        print("***************************************\n")

summarize_all_models(cv_model_lr.subModels)


for i, avg_roc_auc in enumerate(cv_model_lr.avgMetrics):
    print("Avg. ROC AUC computed across k-fold cross validation for model setting #{:d}: {:.3f}".format(i+1, avg_roc_auc))

print("Best model according to k-fold cross validation: lambda=[{:.3f}]; alfa=[{:.3f}]; maxiter=[{:.3f}]".
      format(cv_model_lr.bestModel.stages[-1]._java_obj.getRegParam(), 
             cv_model_lr.bestModel.stages[-1]._java_obj.getElasticNetParam(),
             cv_model_lr.bestModel.stages[-1]._java_obj.getMaxIter(),
             )
      )
print(cv_model_lr.bestModel.stages[-1])

"""## Random Forest"""

def matrix_factorization(train, k_fold=5):

    from pyspark.ml.tuning import CrossValidator, ParamGridBuilder
    from pyspark.ml.evaluation import RegressionEvaluator
    from pyspark.ml import Pipeline
    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler, StandardScaler


    indexers = [StringIndexer(inputCol=c, outputCol="{}_indexed".format(c), handleInvalid="skip") for c in CATEGORICAL_FEATURES]
    
    encoder = OneHotEncoder(inputCols=[indexer.getOutputCol() for indexer in indexers], outputCols=["{}_encoded".format(indexer.getOutputCol()) for indexer in indexers], handleInvalid="keep")
    
    label_indexer = StringIndexer(inputCol='satisfaction', outputCol="label", handleInvalid="skip")
    
    assembler = VectorAssembler(inputCols=encoder.getOutputCols() + NUMERICAL_FEATURES, outputCol="features")
    
    classifier = RandomForestClassifier()

    scaler_vect = StandardScaler(inputCol=assembler.getOutputCol(), outputCol="std_"+assembler.getOutputCol(), withStd=True, withMean=True)
    stages = indexers + [encoder] + [label_indexer] + [assembler] + [scaler_vect] + [classifier]    
      
    pipeline = Pipeline(stages=stages)
    '''    
    if target_variable != "label":
        df = df.withColumnRenamed(target_variable, "label")
    '''

    param_grid = ParamGridBuilder()\
        .addGrid(classifier.maxDepth, [3, 5, 8]) \
        .addGrid(classifier.numTrees, [10, 50, 100]) \
        .build()
    
    cross_val = CrossValidator(estimator=pipeline, 
                               estimatorParamMaps=param_grid,
                               evaluator=BinaryClassificationEvaluator(metricName="areaUnderROC"),
                               numFolds=k_fold,
                               collectSubModels=True # this flag allows us to store ALL the models trained during k-fold cross validation
                               )

    # Run cross-validation, and choose the best set of parameters.
    cv_model = cross_val.fit(train)

    return cv_model

tdf = train_df
cv_model_rf = matrix_factorization(train_df)

def summarize_all_models(cv_models):
    for k, models in enumerate(cv_models):
        print("*************** Fold #{:d} ***************\n".format(k+1))
        for i, m in enumerate(models):
            print("--- Model #{:d} out of {:d} ---".format(i+1, len(models)))
            print("\tParameters: maxDepth=[{:.3f}]; numTrees=[{:.3f}] ".format(m.stages[-1]._java_obj.getMaxDepth(), m.stages[-1]._java_obj.getNumTrees()))
            print("\tModel summary: {}\n".format(m.stages[-1]))
        print("***************************************\n")

summarize_all_models(cv_model_rf.subModels)


for i, avg_roc_auc in enumerate(cv_model_rf.avgMetrics):
    print("Avg. ROC AUC computed across k-fold cross validation for model setting #{:d}: {:.3f}".format(i+1, avg_roc_auc))

print("Best model according to k-fold cross validation: maxDepth=[{:.3f}]; numTrees=[{:.3f}]".
      format(cv_model_rf.bestModel.stages[-1]._java_obj.getMaxDepth(), 
             cv_model_rf.bestModel.stages[-1]._java_obj.getNumTrees(),
             )
      )
print(cv_model_rf.bestModel.stages[-1])

"""## Decison Tree"""

def matrix_factorization(train, k_fold=5):

    from pyspark.ml.tuning import CrossValidator, ParamGridBuilder
    from pyspark.ml.evaluation import RegressionEvaluator
    from pyspark.ml import Pipeline
    from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler, StandardScaler


    indexers = [StringIndexer(inputCol=c, outputCol="{}_indexed".format(c), handleInvalid="skip") for c in CATEGORICAL_FEATURES]
    
    encoder = OneHotEncoder(inputCols=[indexer.getOutputCol() for indexer in indexers], outputCols=["{}_encoded".format(indexer.getOutputCol()) for indexer in indexers], handleInvalid="keep")
    
    label_indexer = StringIndexer(inputCol='satisfaction', outputCol="label", handleInvalid="skip")
    
    assembler = VectorAssembler(inputCols=encoder.getOutputCols() + NUMERICAL_FEATURES, outputCol="features")
    
    classifier = DecisionTreeClassifier()

    scaler_vect = StandardScaler(inputCol=assembler.getOutputCol(), outputCol="std_"+assembler.getOutputCol(), withStd=True, withMean=True)
    stages = indexers + [encoder] + [label_indexer] + [assembler] + [scaler_vect] + [classifier]    
      
    pipeline = Pipeline(stages=stages)
    '''    
    if target_variable != "label":
        df = df.withColumnRenamed(target_variable, "label")
    '''

    param_grid = ParamGridBuilder()\
        .addGrid(classifier.maxDepth, [3, 5, 8]) \
        .addGrid(classifier.impurity, ["gini", "entropy"]) \
        .build()
    
    cross_val = CrossValidator(estimator=pipeline, 
                               estimatorParamMaps=param_grid,
                               evaluator=BinaryClassificationEvaluator(metricName="areaUnderROC"),
                               numFolds=k_fold,
                               collectSubModels=True # this flag allows us to store ALL the models trained during k-fold cross validation
                               )

    # Run cross-validation, and choose the best set of parameters.
    cv_model = cross_val.fit(train)

    return cv_model

cv_model_dt = matrix_factorization(train_df)

def summarize_all_models(cv_models):
    for k, models in enumerate(cv_models):
        print("*************** Fold #{:d} ***************\n".format(k+1))
        for i, m in enumerate(models):
            print("--- Model #{:d} out of {:d} ---".format(i+1, len(models)))
            print("\tParameters: maxDepth=[{:.3f}]; impurity=[{:s}] ".format(m.stages[-1]._java_obj.getMaxDepth(), m.stages[-1]._java_obj.getImpurity()))
            print("\tModel summary: {}\n".format(m.stages[-1]))
        print("***************************************\n")

summarize_all_models(cv_model_dt.subModels)


for i, avg_roc_auc in enumerate(cv_model_dt.avgMetrics):
    print("Avg. ROC AUC computed across k-fold cross validation for model setting #{:d}: {:.3f}".format(i+1, avg_roc_auc))

print("Best model according to k-fold cross validation: maxDepth=[{:.3f}]; impurity=[{:s}]".
      format(cv_model_dt.bestModel.stages[-1]._java_obj.getMaxDepth(), 
             cv_model_dt.bestModel.stages[-1]._java_obj.getImpurity(),
             )
      )
print(cv_model_dt.bestModel.stages[-1])